#pragma kernel CSMain
#pragma kernel Mix
#include "Ray.hlsl"

Texture2D<float4> Scene;
RWTexture2D<float4> Downscale;
Texture2D<float4> Upscale;
RWTexture2D<float4> Result; 
int Width;
int Height;
int DownscaleFactor;
int SamplesPerPixel;
float BlendAmount; 

struct Camera {
    float3 origin;
    float3 lower_left_corner;
    float3 horizontal;
    float3 vertical;
    
    void setup() {
        const float aspect_ratio = float(Width) / float(Height);
        float viewport_height = 2.0; 
        float viewport_width = aspect_ratio * viewport_height;
        float focal_length = 1.0;

        origin = float3(0, 0, 0);
        horizontal = float3(viewport_width, 0.0, 0.0);
        vertical = float3(0.0, viewport_height, 0.0);
        lower_left_corner = origin - horizontal/2 - vertical/2 - float3(0, 0, focal_length);
    }

    Ray get_ray(float u, float v) {
        float3 direction = lower_left_corner + u*horizontal + v*vertical - origin;
        Ray ray = {
            origin.x, origin.y, origin.z,
            direction.x, direction.y, direction.z
        };
        return ray;
    }
};

float3 ray_color(float2 id, Ray ray, Sphere spheres[3])
{
    int depth = 8;
    Ray current_ray = ray;
    
    float3 unit_direction = unit_vector(ray.direction);
    float t = 0.5*(unit_direction.y + 1.0);
    float3 current_color = (1.0-t)*float3(1.0, 1.0, 1.0) + t*float3(0.5, 0.7, 1.0);

    HitRecord rec;
    float t_min = 0.001;
    float t_max = 99999999;
    
    // Depth is number bounces, one ray per bounce
    while(depth > 0)
    {
        bool hit_anything = false; 
        float closest_so_far = t_max;
        Material material;

        // Iterate over objects, finding closest hit
        for (int i = 0; i < 3; i++) {
            if (spheres[i].hit(current_ray, t_min, closest_so_far, rec)) {
                hit_anything = true; 
                closest_so_far = rec.t;
                material = spheres[i].material;
            }
        }

        if(hit_anything)
        {
            // float3 attenuation;
            // if (material.scatter(current_ray, rec, attenuation))
            // {
                // current_color = attenuation * current_color;
                // depth --;
                // continue;
            // }
            float3 target = rec.p + random_in_hemisphere(id,rec.normal);
            current_ray.origin = rec.p;
            current_ray.direction = target - rec.p;
            current_color = 0.5 * current_color;
            depth --;
            continue;
        }
        return current_color;
    }
    // If we've exceeded the ray bounce limit, no more light is gathered.
    return 0;
}


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Image
    float2 sample_positions[16] = {
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
    };
    if( SamplesPerPixel == 2)
    {
        sample_positions[0] =  float2(-0.25,0.25);
        sample_positions[1] = float2(0.25,-0.25);
    }
    if( SamplesPerPixel == 4) 
    {
        sample_positions[0] =  float2(-0.375,-0.125);
        sample_positions[1] = float2(-0.125,0.375);
        sample_positions[2]= float2(0.375,0.125);
        sample_positions[3]= float2(0.125,-0.375);
    }
    if( SamplesPerPixel == 8) 
    {
        sample_positions[0] =  float2(0.0625,-0.1875);
        sample_positions[1] =  float2(-0.0625,0.1875);
        sample_positions[2] =  float2(0.3125,0.0625);
        sample_positions[3] =  float2(-0.1875,-0.3125);
        sample_positions[4] =  float2(-0.3125,0.3125);
        sample_positions[5] =  float2(-0.4375,-0.0625);
        sample_positions[6] =  float2(0.1875,0.4375);
        sample_positions[7] =  float2(0.4375,0.4375);
    }
    if( SamplesPerPixel == 16) 
    {
        sample_positions[0] =  float2(0.0625,0.0625);
        sample_positions[1] =  float2(-0.0625,-0.1875);
        sample_positions[2] =  float2(-0.1875,0.125);
        sample_positions[3] =  float2(0.25,-0.0625);
        sample_positions[4] =  float2(-0.3125,-0.125);
        sample_positions[5] =  float2(0.125,0.3125);
        sample_positions[6] =  float2(0.3125,0.1875);
        sample_positions[7] =  float2(0.1875,-0.3125);
        sample_positions[8] =  float2(-0.125,0.375);
        sample_positions[9] =  float2(0,-0.4375);
        sample_positions[10] =  float2(-0.25,-0.375);
        sample_positions[11] =  float2(-0.375,0.25);
        sample_positions[12] =  float2(-0.5,0);
        sample_positions[13] =  float2(0.4375,-0.25);
        sample_positions[14] =  float2(0.375,0.4375);
        sample_positions[15] =  float2(-0.4375,-0.5);
    }
    
    // Camera
    Camera cam;
    cam.setup();

    // Render
    float3 pixel_color = 0.0;
    Material metal = {
        1,0,0
    };
    
    Sphere s1;
    s1.center = float3(-0.5,0,-1);
    s1.radius = 0.5;
    s1.material = metal;
    
    Sphere s2;
    s2.center = float3(0.5, 0.1 + _SinTime.w * 0.2,-1);
    s2.radius = 0.4;
    s2.material = metal;
    
    Sphere s3;
    s3.center = float3(0,-100.5,-1);
    s3.radius = 100;
    s3.material = metal;
    
    // World
    Sphere spheres[3] = {
        s1,
        s2,
        s3
    };

    for (int s = 0; s < SamplesPerPixel; ++s) {
        float u = float(id.x + sample_positions[s].x) / (Width-1);
        float v = float(id.y + sample_positions[s].y) / (Height-1);
        Ray ray = cam.get_ray(u, v);
        pixel_color += ray_color(float2(u,v), ray, spheres);
    }
    pixel_color = write_color(pixel_color, SamplesPerPixel);
    
    Downscale[id.xy] = float4(pixel_color, 1.0);
}

[numthreads(8,8,1)]
void Mix (uint3 id : SV_DispatchThreadID)
{
    Result[id.xy] = lerp(Upscale[id.xy], Scene[id.xy], BlendAmount);
}
