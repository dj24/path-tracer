#pragma kernel Mix
#pragma kernel Trace1
#pragma kernel Trace2
#pragma kernel Trace4
#pragma kernel Trace8
#pragma kernel Trace16

#include "Ray.hlsl"

Texture2D<float4> Scene;
RWTexture2D<float4> Downscale;
ByteAddressBuffer VertexBuffer;
ByteAddressBuffer IndexBuffer;
Texture2D<float4> Upscale;
Texture2D<float> Depth;
TextureCube<float4> Skybox;
SamplerState samplerSkybox; 
RWTexture2D<float4> Result;
float4x4 WorldToLocal;
float4x4 LocalToWorld;

int Width; 
int Height;
int DownscaleFactor;
int TriangleCount;
int SamplesPerPixel;
int VertexStride;
float VerticalFov;
bool UseAccumulation;
float3 CameraDirection;
float3 MeshOrigin;

struct Camera {
    float3 lower_left_corner;
    float3 horizontal;
    float3 vertical;
    
    void setup() {
        float3 vup = float3(0,1,0);
        const float aspect_ratio = float(Width) / float(Height);
        float theta = degrees_to_radians(VerticalFov);
        float h = tan(theta/2.0);
        float viewport_height = 2.0 * h;
        float viewport_width = aspect_ratio * viewport_height;
        
        float3 w = unit_vector(CameraDirection);
        float3 u = unit_vector(cross(vup, w));
        float3 v = cross(w, u);
        
        horizontal = -viewport_width * u;
        vertical = viewport_height * v;
        lower_left_corner = _WorldSpaceCameraPos - horizontal/2 - vertical/2 - w;
    }

    Ray get_ray(float u, float v) {
        float3 direction = lower_left_corner + u*horizontal + v*vertical - _WorldSpaceCameraPos;
        Ray ray = {
            _WorldSpaceCameraPos.x, _WorldSpaceCameraPos.y, _WorldSpaceCameraPos.z,
            direction.x, direction.y, direction.z
        };
        return ray;
    }
};

float3 multVecMatrix(float3 src, float4x4 m)
{
    // float3 dst;
    float3 translation = float3(m[0][3], m[1][3], m[2][3]);
    float3 scale = float3(abs(m[0][0]), abs(m[1][1]), abs(m[2][2]));
    // float rotatedX = 
    // return src + translation;
    return src * scale + translation;
} 

groupshared float4 sample_colours[16];

void PathTrace(uint2 id, uint sample)
{
    if(Depth[id.xy * DownscaleFactor] == 0)
    {
        // If not rendering, dont sample
        Downscale[id.xy] = 0;
        return;
    }
    // Image
    float2 sample_positions[16] = {
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0, 
    };
    if( SamplesPerPixel == 2)
    {
        sample_positions[0] =  float2(-0.25,0.25);
        sample_positions[1] = float2(0.25,-0.25);
    }
    if( SamplesPerPixel == 4) 
    {
        sample_positions[0] =  float2(-0.375,-0.125);
        sample_positions[1] = float2(-0.125,0.375);
        sample_positions[2]= float2(0.375,0.125);
        sample_positions[3]= float2(0.125,-0.375);
    }
    if( SamplesPerPixel == 8) 
    {
        sample_positions[0] =  float2(0.0625,-0.1875);
        sample_positions[1] =  float2(-0.0625,0.1875);
        sample_positions[2] =  float2(0.3125,0.0625);
        sample_positions[3] =  float2(-0.1875,-0.3125);
        sample_positions[4] =  float2(-0.3125,0.3125);
        sample_positions[5] =  float2(-0.4375,-0.0625);
        sample_positions[6] =  float2(0.1875,0.4375);
        sample_positions[7] =  float2(0.4375,0.4375);
    }
    if( SamplesPerPixel == 16) 
    {
        sample_positions[0] =  float2(0.0625,0.0625);
        sample_positions[1] =  float2(-0.0625,-0.1875);
        sample_positions[2] =  float2(-0.1875,0.125);
        sample_positions[3] =  float2(0.25,-0.0625);
        sample_positions[4] =  float2(-0.3125,-0.125);
        sample_positions[5] =  float2(0.125,0.3125);
        sample_positions[6] =  float2(0.3125,0.1875);
        sample_positions[7] =  float2(0.1875,-0.3125);
        sample_positions[8] =  float2(-0.125,0.375);
        sample_positions[9] =  float2(0,-0.4375);
        sample_positions[10] =  float2(-0.25,-0.375);
        sample_positions[11] =  float2(-0.375,0.25);
        sample_positions[12] =  float2(-0.5,0);
        sample_positions[13] =  float2(0.4375,-0.25);
        sample_positions[14] =  float2(0.375,0.4375);
        sample_positions[15] =  float2(-0.4375,-0.5);
    }
    
    // Camera
    Camera cam;
    cam.setup();
    

    // Render
    Material metal = {
        0.5, 0.5, 0.5,
        true,
        0.0
    };
    
    float u = float(id.x + sample_positions[sample].x) / (Width-1);
    float v = float(id.y + sample_positions[sample].y) / (Height-1);
    Ray ray = cam.get_ray(u, v);

    // Trace Sample
    const int max_depth = 2;
    const float t_min = 0.001;
    const float t_max = 99999999;
    
    int depth = max_depth;
    float3 current_color = 1.0; // Light colour

    HitRecord rec;
    
    // Depth is number bounces, one ray per bounce
    while(depth > 0)
    {
        bool hit_anything = false;
        // bool should_sample_light = random(id) > 0.1;
        bool should_sample_light = false;
        float closest_so_far = t_max;
        Material material;
        
        // Iterate over objects, finding closest hit
        for (int i = 0; i < TriangleCount; i++) {
            Triangle tri;
            uint id0, id1, id2;
            // Unpack 2 byte indicies
            // TODO: pass in mesh index format
            if(i % 2 == 0)
            {
                id0 = UnpackUint2x16(IndexBuffer.Load(i * 6)).x; 
                id1 = UnpackUint2x16(IndexBuffer.Load(i * 6)).y;
                id2 = UnpackUint2x16(IndexBuffer.Load(i * 6 + 4)).x;
            }
            else
            {
                id0 = UnpackUint2x16(IndexBuffer.Load(i * 6 - 2)).y;
                id1 = UnpackUint2x16(IndexBuffer.Load(i * 6 + 2)).x;
                id2 = UnpackUint2x16(IndexBuffer.Load(i * 6 + 2)).y;
            }

            tri.v0 = mul(LocalToWorld,float4(asfloat(VertexBuffer.Load3(id0 * VertexStride)),1.0));
            tri.v1 = mul(LocalToWorld,float4(asfloat(VertexBuffer.Load3(id1 * VertexStride)),1.0));
            tri.v2 = mul(LocalToWorld,float4(asfloat(VertexBuffer.Load3(id2 * VertexStride)),1.0)); 
            
            if (tri.hit(ray, t_min, closest_so_far, rec)) {
                hit_anything = true; 
                closest_so_far = rec.t;
                material = metal;
            }
        }
        if(hit_anything)
        {
            if(should_sample_light)
            {
                ray =  material.direct_light(id, rec); // Towards Light
                current_color = 0;
            }
            else
            {
                float3 attenuation;
                ray = material.scatter(id, ray, rec, attenuation);
                current_color = attenuation * current_color;
            }
            depth --;
            continue;
        }
        float3 sky_color = Skybox.SampleLevel( samplerSkybox, float4( unit_vector(ray.direction).xyz, 0 ), 0.0 ).xyz;
        current_color = sky_color * current_color;
        break;
    }
    sample_colours[sample] = float4(current_color, depth == max_depth ? 0.0 : 1.0);

    // Only run once per pixel
    if(sample > 0)
    {
        return;
    }
    float4 pixel_color = 0.0;
    for (int s = 0; s < SamplesPerPixel; ++s)
    {
        pixel_color += sample_colours[s];
    }
    if(UseAccumulation)
    {
        float mixAmount = 0.5;
        Downscale[id.xy] = lerp(Downscale[id.xy],write_color(pixel_color, SamplesPerPixel), mixAmount);
    }
    else
    {
        Downscale[id.xy] = write_color(pixel_color, SamplesPerPixel);
    }
    
}
 
[numthreads(1,1,1)]
void Trace1 (uint2 id : SV_GroupID)
{
    PathTrace(id, 0); 
}

[numthreads(2,1,1)]
void Trace2 (uint2 id : SV_GroupID, uint sample : SV_GroupThreadID)
{
    PathTrace(id, sample);
}

[numthreads(4,1,1)]
void Trace4 (uint2 id : SV_GroupID, uint sample : SV_GroupThreadID)
{
    PathTrace(id, sample);
}

[numthreads(8,1,1)]
void Trace8 (uint2 id : SV_GroupID, uint sample : SV_GroupThreadID)
{
    PathTrace(id, sample);
}

[numthreads(16,1,1)]
void Trace16 (uint2 id : SV_GroupID, uint sample : SV_GroupThreadID)
{
    PathTrace(id, sample);
}

// TODO: Fix texture name mismatch
[numthreads(1,1,1)]
void Mix (uint3 id : SV_DispatchThreadID) 
{
    Result[id.xy] = lerp(Upscale[id.xy], Scene[id.xy], Scene[id.xy].w);
}
