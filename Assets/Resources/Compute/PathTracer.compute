#pragma kernel Trace

// TODO: add samples over time - 16 sub pixels over 16 frames

#include "Ray.hlsl"

RWTexture2D<float4> Downscale;
RWStructuredBuffer<Triangle> SceneTriangles;
Texture2D<float> Depth;
TextureCube<float4> Skybox;
SamplerState samplerSkybox; 
RWTexture2D<float4> Result;

float2 SamplePositions[16];
int FrameNumber;
int Width; 
int Height;
int DownscaleFactor;
int TriangleCount;
int MaxBounces;
float VerticalFov;
float MaterialFuzz;
bool UseAccumulation;
bool IsMetal;
float3 CameraDirection;
float3 MeshOrigin;
float3 Color;
  
[numthreads(8,8,1)]
void Trace(uint2 id : SV_DispatchThreadID)
{
    if(Depth[id * DownscaleFactor] == 0)
    {
        // If not rendering, dont sample
        Downscale[id] = 0;
        return;
    }
   
    // Camera
    Camera cam;
    cam.setup(Width, Height, VerticalFov, CameraDirection);
    
    // Render
    Material metal = {
        Color.r, Color.g, Color.b,
        true,
        MaterialFuzz
    };
    float u, v;
    if(UseAccumulation)
    {
        u = float(float(id.x + SamplePositions[FrameNumber].x) / Width);
        v = float(float(id.y + SamplePositions[FrameNumber].y) / Height);
        
    } else
    {
        u = float(float(id.x) / Width);
        v = float(float(id.y) / Height);
    }
    Ray ray = cam.get_ray(u, v);

    // Trace Sample
    int depth = MaxBounces;
    float3 current_color = 1.0; // Light colour

    HitRecord rec;

    float lowest_t = 999999999999.0; 
    // Depth is number bounces, one ray per bounce
    while(depth > 0)
    {
        bool hit_anything = false;
        // bool should_sample_light = random(id) > 0.1;
        bool should_sample_light = false;
        Material material;
        
        
        // Iterate over objects, finding closest hit
        for (int i = 0; i < TriangleCount; i++) {
            Triangle tri = SceneTriangles[i];
            float3 uvw;
            if (tri.hit(ray,rec,uvw) && rec.t < lowest_t) {
                hit_anything = true; 
                Material new_material = metal;
                new_material.isMetal = IsMetal;
                new_material.albedo = uvw;
                lowest_t = rec.t;
                material = new_material;
            }
        }
        if(hit_anything)
        {
            if(should_sample_light)
            {
                ray =  material.direct_light(id, rec); // Towards Light
                current_color = 0;
            }
            else
            {
                float3 attenuation;
                ray = material.scatter(id, ray, rec, attenuation);
                current_color = attenuation * current_color;
            }
            depth --;
            continue;
        }
        float3 sky_color = Skybox.SampleLevel( samplerSkybox, float4( unit_vector(ray.direction).xyz, 0 ), 0.0 ).xyz;
        current_color = sky_color * current_color;
        break;
    }
    float4 pixel_color = float4(current_color, depth == MaxBounces ? 0.0 : 1.0);
    Downscale[id] =
        UseAccumulation
            ? lerp(Downscale[id.xy],pixel_color, 1.0/16.0)
            : pixel_color;
}