#pragma kernel CSMain
#pragma kernel Mix
#include "Ray.hlsl"

Texture2D<float4> Scene;
RWTexture2D<float4> Downscale;
Texture2D<float4> Upscale;
RWTexture2D<float4> Result; 
int Width;
int Height;
int DownscaleFactor;
bool MultiSample;
float BlendAmount; 

struct Camera {
    float3 origin;
    float3 lower_left_corner;
    float3 horizontal;
    float3 vertical;
    
    void setup() {
        const float aspect_ratio = float(Width) / float(Height);
        float viewport_height = 2.0; 
        float viewport_width = aspect_ratio * viewport_height;
        float focal_length = 1.0;

        origin = float3(0, 0, 0);
        horizontal = float3(viewport_width, 0.0, 0.0);
        vertical = float3(0.0, viewport_height, 0.0);
        lower_left_corner = origin - horizontal/2 - vertical/2 - float3(0, 0, focal_length);
    }

    Ray get_ray(float u, float v) {
        float3 direction = lower_left_corner + u*horizontal + v*vertical - origin;
        Ray ray = {
            origin.x, origin.y, origin.z,
            direction.x, direction.y, direction.z
        };
        return ray;
    }
};

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Image
    int samples_per_pixel = 1;
    float2 sample_positions[4] = {
        0,0,0,0,0,0,0,0
    };
    if(MultiSample) 
    {
        samples_per_pixel = 4;
        sample_positions[0] =  float2(-0.4,-0.1);
        sample_positions[1] = float2(-0.1,0.4);
        sample_positions[2]= float2(0.4,0.1);
        sample_positions[3]= float2(0.1,-0.4);
    }
    
    // World
    Sphere spheres[2] = {
        {
            0,0,-1,
            0.5,
        },
        {
        0,-100.5,-1,
        100}
    };
    
    // Camera
    Camera cam;
    cam.setup();

    // Render
    float3 pixel_color = 0.0;
    HitRecord rec;

    for (int s = 0; s < samples_per_pixel; ++s) {
        float3 ray_color;
        float u = float(id.x + sample_positions[s].x) / (Width-1);
        float v = float(id.y + sample_positions[s].y) / (Height-1);
        Ray ray = cam.get_ray(u, v);
        // Check Objects
        HitRecord temp_rec;
        float t_min = 0;
        float t_max = 999999;
        bool hit_anything = false;
        float closest_so_far = t_max;

        for (int i = 0; i < 2; i++) {
            if (spheres[i].hit(ray, t_min, closest_so_far, temp_rec)) {
                hit_anything = true;
                closest_so_far = temp_rec.t;
                rec = temp_rec;
            }
        }

        if(hit_anything)
        {
            float3 N = rec.normal;
            ray_color = 0.5*float3(N.x+1, N.y+1, N.z+1);
        }
        else
        {
            float3 unit_direction = unit_vector(ray.direction);
            float t = 0.5*(unit_direction.y + 1.0);
            ray_color = (1.0-t)*float3(1.0, 1.0, 1.0) + t*float3(0.5, 0.7, 1.0);
        }
        pixel_color += ray_color;
    }
    pixel_color = write_color(pixel_color, samples_per_pixel);
    
    Downscale[id.xy] = float4(pixel_color, 1.0);
}

[numthreads(8,8,1)]
void Mix (uint3 id : SV_DispatchThreadID)
{
    Result[id.xy] = lerp(Upscale[id.xy], Scene[id.xy], BlendAmount);
}
