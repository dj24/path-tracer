#pragma kernel Trace

#include "Ray.hlsl"

struct MeshTriangleOffset
{
    int startIndex;
    int endIndex;
};

RWTexture2D<float4> Downscale;
RWStructuredBuffer<Triangle> SceneTriangles;
RWStructuredBuffer<MeshTriangleOffset> MeshTrianglesOffsets;
TextureCube<float4> Skybox;
SamplerState samplerSkybox;
Texture2D<float3> Motion;

float2 SamplePositions[16]; 
int FrameNumber;
int Width; 
int Height;
int DownscaleFactor;
int TriangleCount;
int MaxBounces;
int MeshCount;
float VerticalFov;
float MaterialFuzz;
bool UseAccumulation;
bool IsMetal;
float3 CameraDirection;
float3 MeshOrigin;
float3 Color;


[numthreads(8,8,1)]
void Trace(uint3 d : SV_DispatchThreadID)
{
    uint2 id = d.xy;
    
    // Camera
    Camera cam;
    cam.setup(Width, Height, VerticalFov, CameraDirection);
    
    // Render
    Material metal = {
        Color.r, Color.g, Color.b,
        true,
        MaterialFuzz
    };
    float u, v;
    const float uMultiplier = 1 + SamplePositions[FrameNumber / 16].x;
    const float vMultiplier = 1 + SamplePositions[FrameNumber / 16].y;
    if(UseAccumulation)
    {
        u = float(id.x + SamplePositions[FrameNumber % 16].x * uMultiplier) / Width;
        v = float(id.y + SamplePositions[FrameNumber % 16].y * vMultiplier) / Height;
        
    } else
    {
        u = float(id.x) / Width;
        v = float(id.y) / Height;
    }
    Ray ray = cam.get_ray(u, v);
    
    // Trace Sample
    int depth = MaxBounces;
    float3 current_color = 1.0; // Light colour

    HitRecord rec;
    HitRecord closest;
    
    float lowest_t = 999999999999.0;
    
    // Depth is number bounces, one ray per bounce
    while(depth > 0)
    {
        bool hit_anything = false;
        Material material;

        // Iterate over meshes, finding closest hit
        for(int m = 0; m < MeshCount; m++)
        {
            MeshTriangleOffset meshOffset = MeshTrianglesOffsets[m];
            // Iterate over triangles, finding closest hit
            for (int i = meshOffset.startIndex; i < meshOffset.endIndex; i++) {
                float3 uvw;
                if (SceneTriangles[i].hit(ray,rec,uvw) && rec.t < lowest_t) {
                    hit_anything = true; 
                    Material new_material = metal;
                    new_material.isMetal = IsMetal;
                    new_material.albedo = LoadSceneNormals(id);
                    lowest_t = rec.t;
                    closest = rec;
                    material = new_material;
                }
            }
        }
        
        if(hit_anything)
        {
            float3 attenuation;
            ray = material.scatter(float2(u,v), ray, closest, attenuation);
            current_color = attenuation * current_color;
            depth --;
            continue;
        }
        // if nothing hit, sample sky and sun
        break;
    }
    
    // Ray sunRay;
    // sunRay.origin = float3(100,100,0);
    // //TODO get actual light position
    // sunRay.direction = -normalize(closest.p - sunRay.origin);
    // HitRecord sunRec;
    // float3 uvw;
    // bool isSunOccluded = true;
    // // Iterate over meshes, checking if direction light is occluded
    // for(int m = 0; m < MeshCount; m++)
    // {
    //     MeshTriangleOffset meshOffset = MeshTrianglesOffsets[m];
    //     for (int i = meshOffset.startIndex; i < meshOffset.endIndex; i++) {
    //         if (!SceneTriangles[i].hit(sunRay,sunRec,uvw)) {
    //             isSunOccluded = false;
    //         }
    //     }
    // }
        
    float3 sky_color = Skybox.SampleLevel( samplerSkybox, float4( unit_vector(ray.direction).xyz, 0 ), 0.0 ).xyz;
    current_color = sky_color * current_color;
    
    float4 pixel_color = float4(current_color, depth == MaxBounces ? 0.0 : 1.0);
    float blend_amount = abs(Motion[id.xy * DownscaleFactor]) > 0 || Downscale[id.xy].w == 0 ? 1.0 : 1.0/8.0;
    Downscale[id] =
        UseAccumulation
            ? lerp(Downscale[id.xy],pixel_color, blend_amount)
            : pixel_color;
}